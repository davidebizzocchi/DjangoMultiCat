# This are copied core classes

import time
from enum import Enum
from typing import Dict, List, Literal, Optional

from pydantic import BaseModel, Field, ConfigDict, computed_field

class Notification(BaseModel):
    type: str = "notification"
    content: str
    received_at: float = Field(default_factory=lambda: time.time())

    @property
    def message(self):
        return self.content

class DocReadingProgress(BaseModel):
    type: Literal["doc-reading-progress"]
    status: Literal["done", "progress"]
    perc_read: int 
    source: str
    received_at: float = Field(default_factory=lambda: time.time())

class AgentRequest(BaseModel):
    name: str
    instructions: str
    metadata: Dict = Field(default_factory=dict)
    enable_vector_search: bool = Field(default=True)

class Agent(AgentRequest):
    id: str = "default"

class ModelInteraction(BaseModel):
    """
    Base class for interactions with models, capturing essential attributes common to all model interactions.

    Attributes
    ----------
    model_type : Literal["llm", "embedder"]
        The type of model involved in the interaction, either a large language model (LLM) or an embedder.
    source : str
        The source from which the interaction originates.
    prompt : str
        The prompt or input provided to the model.
    input_tokens : int
        The number of input tokens processed by the model.
    started_at : float
        The timestamp when the interaction started. Defaults to the current time.
    """

    model_type: Literal["llm", "embedder"]
    source: str
    prompt: List[str]
    input_tokens: int
    started_at: float = Field(default_factory=lambda: time.time())

    model_config = ConfigDict(
        protected_namespaces=()
    )

class LLMModelInteraction(ModelInteraction):
    """
    Represents an interaction with a large language model (LLM).

    Inherits from ModelInteraction and adds specific attributes related to LLM interactions.

    Attributes
    ----------
    model_type : Literal["llm"]
        The type of model, which is fixed to "llm".
    reply : str
        The response generated by the LLM.
    output_tokens : int
        The number of output tokens generated by the LLM.
    ended_at : float
        The timestamp when the interaction ended.
    """

    model_type: Literal["llm"] = Field(default="llm")
    reply: str
    output_tokens: int
    ended_at: float

class EmbedderModelInteraction(ModelInteraction):
    """
    Represents an interaction with an embedding model.

    Inherits from ModelInteraction and includes attributes specific to embedding interactions.

    Attributes
    ----------
    model_type : Literal["embedder"]
        The type of model, which is fixed to "embedder".
    source : str
        The source of the interaction, defaulting to "recall".
    reply : List[float]
        The embeddings generated by the embedder.
    """
    model_type: Literal["embedder"] = Field(default="embedder")
    source: str = Field(default="recall")
    reply: List[float]

# Class model copied from utils.py
class BaseModelDict(BaseModel):
    model_config = ConfigDict(
        extra="allow",
        validate_assignment=True,
        arbitrary_types_allowed=True,
        protected_namespaces=() # avoid warning for `model_xxx` attributes
    )

    def __getitem__(self, key):
        # deprecate dictionary usage
        print(
            f'To get `{key}` use dot notation instead of dictionary keys, example:' 
            f'`obj.{key}` instead of `obj["{key}"]`'
        )

        # return attribute
        return getattr(self, key)

    def __setitem__(self, key, value):
        # deprecate dictionary usage
        print(
            f'To set `{key}` use dot notation instead of dictionary keys, example:'
            f'`obj.{key} = x` instead of `obj["{key}"] = x`'
        )

        # set attribute
        setattr(self, key, value)

    def get(self, key, default=None):
        return getattr(self, key, default)

    def __delitem__(self, key):
        delattr(self, key)

    def _get_all_attributes(self):
        # return {**self.model_fields, **self.__pydantic_extra__}
        return self.model_dump()

    def keys(self):
        return self._get_all_attributes().keys()

    def values(self):
        return self._get_all_attributes().values()

    def items(self):
        return self._get_all_attributes().items()

    def __contains__(self, key):
        return key in self.keys()

# Class copied from convo.messages
class Role(Enum):
    """
    Enum representing the roles involved in a conversation.

    Attributes
    ----------
    AI : str
        Represents an artificial intelligence role.
    Human : str
        Represents a human role.
    """

    AI = "AI"
    Human = "Human"

class MessageWhy(BaseModelDict):
    """
    A class for encapsulating the context and reasoning behind a message, providing details on 
    input, intermediate steps, memory, and interactions with models.

    Attributes
    ----------
    input : str
        The initial input message that triggered the response.
    intermediate_steps : List
        A list capturing intermediate steps or actions taken as part of processing the message.
    memory : dict
        A dictionary containing relevant memory information used during the processing of the message.
    model_interactions : List[Union[LLMModelInteraction, EmbedderModelInteraction]]
        A list of interactions with language or embedding models, detailing how models were used in generating 
        or understanding the message context.
    """

    input: str
    intermediate_steps: List
    memory: dict
    model_interactions: List[LLMModelInteraction | EmbedderModelInteraction]

    def get_file_info_from_memory(self, memory_name: str = "declarative", unique=True) -> List[str]:
        """
        Extract file IDs from memory based on the memory name.

        Parameters
        ----------
        memory_name : str, default="declarative"
            The name of the memory to extract file IDs from.

        Returns
        -------
        List[str]
            A list of file IDs extracted from the specified memory.
        """

        class HashableTuple:
            def __init__(self, *args):
                self.tuple_data = tuple(args)

            def __hash__(self):
                # Use only the first element for hashing
                return hash(self.tuple_data[0])

            def __eq__(self, other):
                # Compare only the first element for equality
                return self.tuple_data[0] == other.tuple_data[0]
            
            @property
            def original(self):
                return self.tuple_data

            def __repr__(self):
                return f"HashableTuple({self.tuple_data})"

        if memory_name not in self.memory:
            return []

        file_ids = set() if unique else []

        for mem_point in self.memory[memory_name]:
            metadata = mem_point.get("metadata", {})
            if "file_id" in metadata:
                if unique:
                    file_ids.add(
                        HashableTuple(metadata["file_id"], mem_point["score"])
                    )
                else:
                    file_ids.append(
                        HashableTuple(metadata["file_id"], mem_point["score"])
                    )

        return file_ids
        

class Message(BaseModelDict):
    """
    Base class for working memory history entries.
    Is subclassed by `ConversationMessage`, which in turns is subclassed by `CatMessage` and `UserMessage`.
    
    Attributes
    ----------
    user_id : str
        Unique identifier for the user associated with the message.
    when : float
        The timestamp when the message was sent.
    """

    user_id: str   
    when: float = Field(default_factory=time.time)

class ConversationMessage(Message):
    """
    Base class for conversation messages, containing common attributes shared by all message types.
    Subclassed by `CatMessage` and `UserMessage`.

    Attributes
    ----------
    user_id : str
        Unique identifier for the user associated with the message.
    when : float
        The timestamp when the message was sent. Defaults to the current time.
    who : str
        The name of the message author.
    text : Optional[str], default=None
        The text content of the message.
    image : Optional[str], default=None
        Image file URLs or base64 data URIs that represent image associated with the message.
    audio : Optional[str], default=None
        Audio file URLs or base64 data URIs that represent audio associated with the message.
    """

    who: str
    text: Optional[str]  = None
    image: Optional[str] = None
    audio: Optional[str] = None

    # massage was used in the old history instead of text
    # we need to keep it for backward compatibility
    def __init__(self, **data):

        if "message" in data:
            print("The `message` parameter is deprecated. Use `text` instead.")
            data["text"] = data.pop("message")

        super().__init__(**data)

    @property
    def message(self) -> str:
        """
        This attribute is deprecated. Use `text` instead.

        The text content of the message. Use `text` instead.

        Returns
        -------
        str
            The text content of the message.
        """
        print("The `message` attribute is deprecated. Use `text` instead.")
        return self.text
    
    @message.setter
    def message(self, value):
        print("The `message` attribute is deprecated. Use `text` instead.")
        self.text = value

    @property
    def role(self) -> None:
        """The role of the message author."""
        return None

class UserMessage(ConversationMessage):
    """
    Represents a message from a user, containing text and optional multimedia content such as image and audio.

    This class is used to encapsulate the details of a message sent by a user, including the user's identifier, 
    the text content of the message, and any associated multimedia content such as image or audio files.

    Attributes
    ----------
    user_id : str
        Unique identifier for the user associated with the message.
    when : float
        The timestamp when the message was sent. Defaults to the current time.
    who : str
        The name of the message author.
    text : Optional[str], default=None
        The text content of the message.
    image : Optional[str], default=None
        Image file URLs or base64 data URIs that represent image associated with the message.
    audio : Optional[str], default=None
        Audio file URLs or base64 data URIs that represent audio associated with the message.
    """

    who: str = "Human"

    @property
    def role(self) -> Role:
        """The role of the message author."""
        return Role.Human
